{"id":997668660,"lang":"cpp","lang_name":"C++","time":"5 months, 2 weeks","timestamp":1689693281,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/997668660/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"\nclass Node{\n    public:\n    Node* prev;\n    Node* next;\n    int val;\n    Node(int val){\n        this->val = val;\n        this->prev = NULL;\n        this->next = NULL;\n    }\n    \n};\nclass LRUCache {\npublic:\n    int size;\n    Node* head;\n    Node* tail;\n    int capacity;\n    Node* prev;\n    unordered_map<int, int> map;\n    LRUCache(int capacity) {\n        this->size = 0;\n        this->head = NULL;\n        this->tail = NULL;\n        this->capacity = capacity;\n        this->prev = NULL;\n        \n    }\n    \n    int get(int key) {\n        if(map.find(key) != map.end() && this->tail){\n            Node* temp = new Node(this->tail->val);\n            Node* flag = this->tail->prev;\n            this->tail->prev = NULL;\n            delete this->tail;\n            this->tail = flag;\n            temp->next = head;\n            head->prev = temp;\n            head = temp;\n            return map[key];\n\n        }\n        return -1;\n        \n    }\n    \n    void put(int key, int value) {\n        if(head == NULL){\n            head = new Node(key);\n            tail = head;\n            map[key] = value;\n            this->size++;\n            return;\n        }\n        if(size < capacity){\n            map[key] = value;\n            Node* temp = new Node(key);\n            temp->next = head;\n            head->prev = temp;\n            head = temp;\n            this->size++;\n            return;\n        } else if (this->tail) {\n            map.erase(this->tail->val);\n            Node* flag = this->tail->prev;\n            this->tail->prev = NULL;\n            delete this->tail;\n            this->tail =  flag;\n            this->size--;\n            map[key] = value;\n            Node* temp = new Node(key);\n            temp->next = head;\n            head->prev = temp;\n            head = temp;\n            this->size++;\n            return;\n\n        }\n        \n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"1110000000000000000000","title_slug":"lru-cache","has_notes":false,"flag_type":1}