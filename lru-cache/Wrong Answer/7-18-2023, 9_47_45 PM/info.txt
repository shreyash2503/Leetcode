{"id":997718713,"lang":"cpp","lang_name":"C++","time":"5 months, 2 weeks","timestamp":1689697065,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/997718713/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"\nclass Node{\n    public:\n    Node* prev;\n    Node* next;\n    int val;\n    Node(int val){\n        this->val = val;\n        this->prev = NULL;\n        this->next = NULL;\n    }\n    \n};\nclass LRUCache {\npublic:\n    int size;\n    Node* head;\n    Node* tail;\n    int capacity;\n    unordered_map<int, Node*> map;\n    LRUCache(int capacity) {\n        this->size = 0;\n        this->head = NULL;\n        this->tail = NULL;\n        this->capacity = capacity;\n        \n    }\n    \n    int get(int key) {\n        if(map.find(key) != map.end() && this->head == this->tail){\n            return this->head->val;\n        }\n        if(map.find(key) != map.end() && map[key] == this->head){\n            return this->head->val;\n        }\n        if(map.find(key) != map.end() && map[key] == this->tail){\n            Node* flag = this->tail;\n            Node* temp = this->tail->prev;\n            this->tail->prev = NULL;\n            this->tail = temp;\n            flag->next = head;\n            head->prev = flag;\n            head = flag;\n            return head->val;\n            \n        } else if(map.find(key) != map.end()){\n            Node* temp = map[key];\n            Node* prev = temp->prev;\n            Node* next = temp->next;\n            if(prev){\n                prev->next = next;\n            }\n            if(next){\n                next->prev = prev;\n\n            }\n            temp->prev = NULL;\n            temp->next = NULL;\n\n            temp->next = head;\n            head->prev = temp;\n            head = temp;\n\n            return temp->val;\n        }\n        return -1;\n       \n        \n    }\n    \n    void put(int key, int value) {\n        if(head == NULL){\n            Node* temp = new Node(value);\n            head = temp;\n            tail = temp;\n            map[key] = temp;\n            this->size++;\n            return;\n        }\n        if(size < capacity){\n            Node* temp = new Node(value);\n            temp->next = head;\n            head->prev = temp;\n            head = temp;\n            map[key] = temp;\n            this->size++;\n            return;\n        } else if(this->tail && size == capacity) {\n            map.erase(this->tail->val);\n            Node* flag = this->tail;\n            Node* temp = this->tail->prev;\n            this->tail->prev = NULL;\n            this->tail = temp;\n            flag->val = value;\n\n            flag->next = head;\n            head->prev = flag;\n            head = flag;\n            map[key] = head;\n            return;\n\n\n        }\n\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"1111010111001100000001","title_slug":"lru-cache","has_notes":false,"flag_type":1}