{"id":1100729695,"lang":"cpp","lang_name":"C++","time":"1 month, 1 week","timestamp":1700218775,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1100729695/","is_pending":"Not Pending","title":"Cheapest Flights Within K Stops","memory":"N/A","code":"class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n\n        vector<int> weights(n, INT_MAX);\n\n        weights[src] = 0;\n\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n\n        pq.push({0, src, 0});\n\n        unordered_map<int, vector<pair<int, int>>> map;\n\n        for(auto edge : flights){\n            map[edge[0]].push_back({edge[1], edge[2]});\n        }\n\n        while(!pq.empty()){\n            auto front = pq.top(); pq.pop();\n            int node = get<1>(front);\n            int weight = get<0>(front);\n            int step = get<2>(front); \n            if(step > k) continue;\n\n            for(auto neighbour : map[node]){\n                auto acq = neighbour.first;\n                auto cost = neighbour.second;\n                auto currCost = weight + cost;\n                if(currCost < weights[acq] && step <= k){\n                    weights[acq] = currCost;\n                    pq.push({currCost, acq, step + 1});\n                }\n\n\n            }\n        }\n\n        if(weights[dst] == 1e9) return -1;\n        return weights[dst];\n        \n    }\n};","compare_result":"11101001010101111111111111111010010010101111111001000","title_slug":"cheapest-flights-within-k-stops","has_notes":false,"flag_type":1}